package codegen

import (
	"bytes"
	"go/format"
	"path/filepath"
	"sort"
	"text/template"

	"github.com/fatih/structtag"
	"github.com/octo-cli/octo-cli/internal/generator/util"
	"github.com/spf13/afero"
)

var tmpl = template.Must(template.New("").Parse(tmplFileTmpl))

func init() {
	template.Must(tmpl.New("RunMethodParam").Parse(tmplRunMethodParam))
	template.Must(tmpl.New("RunMethod").Parse(tmplRunMethod))
	template.Must(tmpl.New("StructType").Parse(tmplStructType))
	template.Must(tmpl.New("SvcTmpl").Parse(tmplSvcTmpl))
	template.Must(tmpl.New("CmdHelps").Parse(tmplCmdHelps))
	template.Must(tmpl.New("FlagHelps").Parse(tmplFlagHelps))
}

type CodeBlock struct {
	Code    string
	Imports []string
}

type RunMethodParam struct {
	Name         string
	ValueField   string
	UpdateMethod string
	Import       string
}

// language=GoTemplate
const tmplRunMethodParam = `
{{.UpdateMethod}}("{{.Name}}", c.{{.ValueField}})`

type RunMethod struct {
	ReceiverName string
	Method       string
	URLPath      string
	CodeBlocks   []CodeBlock
}

func (r *RunMethod) imports() []string {
	var imps []string
	for _, block := range r.CodeBlocks {
		imps = append(imps, block.Imports...)
	}
	return uniqueSortedStrings(imps)
}

// language=GoTemplate
const tmplRunMethod = `
func (c *{{.ReceiverName}}) Run(isValueSetMap map[string]bool) error {
	c.SetIsValueSetMap(isValueSetMap)
	c.SetURLPath("{{.URLPath}}"){{range .CodeBlocks}}{{.Code}}{{end}}
	return c.DoRequest("{{.Method}}")
}

`

type paramLocation int

//nolint:deadcode,varcheck
const (
	locInvalid paramLocation = iota
	locPath
	locQuery
	locBody
	locHeader
	locPreview
)

// StructField is one field in a StructTmplHelper
type StructField struct {
	Name          string
	Type          string
	Tags          *structtag.Tags
	Import        string
	ParamLocation paramLocation
	ParamOrder    int
}

func (s StructField) less(o StructField) bool {
	if s.ParamLocation < o.ParamLocation {
		return true
	}
	if s.ParamLocation > o.ParamLocation {
		return false
	}
	if s.ParamOrder < o.ParamOrder {
		return true
	}
	if s.ParamOrder > o.ParamOrder {
		return false
	}
	if util.TagsHasKey(s.Tags, "required") != util.TagsHasKey(o.Tags, "required") {
		return util.TagsHasKey(s.Tags, "required")
	}
	return s.Name < o.Name
}

type StructTmplHelper struct {
	Name   string
	Fields []StructField
}

func (s *StructTmplHelper) imports() []string {
	imps := make([]string, 0, len(s.Fields))
	for _, field := range s.Fields {
		if field.Import == "" {
			continue
		}
		imps = append(imps, field.Import)
	}
	return uniqueSortedStrings(imps)
}

// language=GoTemplate
const tmplStructType = `type {{.Name}} struct { {{range .Fields}}
	{{.Name}} {{.Type}} {{if .Tags}}{{printf "%#q" .Tags}} {{end}}{{end}}
}`

type CmdStructAndMethod struct {
	CmdStruct StructTmplHelper
	RunMethod RunMethod
}

func (s *CmdStructAndMethod) imports() []string {
	imps := append(s.CmdStruct.imports(), s.RunMethod.imports()...)
	return uniqueSortedStrings(imps)
}

type SvcTmpl struct {
	SvcStruct           StructTmplHelper
	CmdStructAndMethods []CmdStructAndMethod
}

func (s *SvcTmpl) imports() []string {
	result := s.SvcStruct.imports()
	for _, csm := range s.CmdStructAndMethods {
		result = append(result, csm.imports()...)
	}
	return uniqueSortedStrings(result)
}

// language=GoTemplate
const tmplSvcTmpl = `{{if .SvcStruct}}{{template "StructType" .SvcStruct}}{{end}}
	{{range .CmdStructAndMethods}}
	{{if .CmdStruct}}{{template "StructType" .CmdStruct}}{{end}}
	{{if .RunMethod}}{{template "RunMethod" .RunMethod}}{{end}}
	{{end}}
`

type FileTmpl struct {
	CmdHelps       map[string]map[string]string
	FlagHelps      map[string]map[string]map[string]string
	PrimaryStructs []StructTmplHelper
	SvcTmpls       []SvcTmpl
}

func (f FileTmpl) Imports() []string {
	var imports []string
	for _, primaryStruct := range f.PrimaryStructs {
		imports = append(imports, primaryStruct.imports()...)
	}
	for _, svcTmpl := range f.SvcTmpls {
		imports = append(imports, svcTmpl.imports()...)
	}
	return uniqueSortedStrings(imports)
}

// language=GoTemplate
const tmplCmdHelps = `
{{if .}}
  var CmdHelps = map[string]map[string]string{
  {{range $topCmd, $topCmdVals := .}}"{{$topCmd}}": {
  {{range $cmd, $help := $topCmdVals}}"{{$cmd}}": {{printf "%q" $help}},
  {{end}}
  },
  {{end}}
  }
{{end}}
`

// language=GoTemplate
const tmplFlagHelps = `
{{if .}}
  var FlagHelps = map[string]map[string]map[string]string{
  {{range $topCmd, $topCmdVals := .}}"{{$topCmd}}": {
  {{range $cmd, $flagHelps := $topCmdVals}}"{{$cmd}}": {
  {{range $flag, $help := $flagHelps}}"{{$flag}}": {{printf "%q" $help}},
  {{end}}
  },
  {{end}}
  },
  {{end}}
  }
{{end}}
`

// language=GoTemplate
const tmplFileTmpl = `// Code generated by octo-cli/generator; DO NOT EDIT.

package generated

{{ $imports := .Imports }}{{if $imports}}
import (
{{range $imports}}{{printf "%q" .}}
{{end}})
{{end}}

{{range .PrimaryStructs}}
    {{template "StructType" .}}
{{end}}

{{range .SvcTmpls}}{{template "SvcTmpl" .}}{{end}}

{{template "CmdHelps" .CmdHelps}}

{{template "FlagHelps" .FlagHelps}}

`

func WriteFiles(files map[string]FileTmpl, outputPath string, fs afero.Fs) error {
	for name, fileTmpl := range files {
		err := writeGoFile(name, fileTmpl, outputPath, fs)
		if err != nil {
			return err
		}
	}
	return nil
}

//writeGoFile executes the named template and does the equivalent of `go fmt` and `goimports` on the output
func writeGoFile(filename string, fileTmpl FileTmpl, path string, fs afero.Fs) error {
	out, err := generateGoFile(fileTmpl)
	if err != nil {
		return err
	}
	fl := filepath.Join(path, filename)
	return afero.WriteFile(fs, fl, out, 0644)
}

func generateGoFile(fileTmpl FileTmpl) ([]byte, error) {
	for _, svcTmpl := range fileTmpl.SvcTmpls {
		tmplSorting(&svcTmpl)
	}
	var buf bytes.Buffer
	err := tmpl.ExecuteTemplate(&buf, "", fileTmpl)
	if err != nil {
		return nil, err
	}
	out, err := format.Source(buf.Bytes())
	if err != nil {
		return nil, err
	}
	return out, nil
}

func sortCmdStructFields(fields []StructField) {
	if len(fields) == 0 {
		return
	}
	newFields := make([]StructField, 0, len(fields))
	holdouts := make([]StructField, 0, len(fields))
	for _, field := range fields {
		if field.Name == "" {
			holdouts = append(holdouts, field)
			continue
		}
		newFields = append(newFields, field)
	}
	sort.Slice(newFields, func(i, j int) bool {
		return newFields[i].less(newFields[j])
	})
	sort.Slice(holdouts, func(i, j int) bool {
		return holdouts[i].Type < holdouts[j].Type
	})
	newFields = append(newFields, holdouts...)
	copy(fields, newFields)
}

func tmplSorting(svcTmpl *SvcTmpl) {
	sort.Slice(svcTmpl.SvcStruct.Fields, func(i, j int) bool {
		return svcTmpl.SvcStruct.Fields[i].Name < svcTmpl.SvcStruct.Fields[j].Name
	})
	for _, csm := range svcTmpl.CmdStructAndMethods {
		sortCmdStructFields(csm.CmdStruct.Fields)
	}
	sort.Slice(svcTmpl.CmdStructAndMethods, func(i, j int) bool {
		return svcTmpl.CmdStructAndMethods[i].CmdStruct.Name < svcTmpl.CmdStructAndMethods[j].CmdStruct.Name
	})
}

func uniqueSortedStrings(strs []string) []string {
	vals := make(map[string]bool, len(strs))
	for _, str := range strs {
		vals[str] = true
	}
	result := make([]string, 0, len(vals))
	for val := range vals {
		result = append(result, val)
	}
	sort.Strings(result)
	return result
}
